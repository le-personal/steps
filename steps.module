<?php

define('STEP_IS_FINAL', 1);

/**
 * Collects all hook_wizard implementations
 */
function _wizard_implements() {
  $wizard = array();
  foreach(module_list() as $module) {
    if($data = module_invoke($module, 'wizard')) {
      $wizard = array_merge($data, $wizard);
    }
  }
  
  return $wizard;
}

/**
 * Collects all hook_steps implementations
 */
function _steps_implements() {
  $steps = steps_get_steps();
  /*
  $steps = array();
  foreach(module_list() as $module) {
    if($data = module_invoke($module, 'steps')) {
      $steps = array_merge($data, $steps);
    }
  }
  */
  
  return $steps;
}

/**
 * Implements hook_enable()
 */
function steps_enable() {
  /**
   * Create all menu links implementing hook_wizard
   */
  $wizards = _wizard_implements();
  foreach($wizards as $key => $element) {
    $wizard = new stdClass();
    $wizard->wizard = $key;
    $wizard->title = check_plain($element['title']);
    $wizard->main_path = check_plain($element['main_path']);
    $wizard->start_path = check_plain($element['start_path']);
    $wizard->end_path = check_plain($element['end_path']);
    
    steps_wizard_ops($wizard);
  }
  
  /**
   * Create all menus implementing hook_steps
   * There is a problem with how the db_insert is handling array of arrays
   * like in options and validations
   */
  $steps = _steps_implements();
  foreach($steps as $key => $element) {
    $step = new stdClass();
    $step->step = $key;
    $step->wizard = check_plain($element['wizard']);
    $step->title = check_plain($element['title']);
    $step->path = check_plain($element['path']);
    $step->description = isset($element['description']) ? check_plain($element['description']) : NULL;
    $step->component_type = $element['component']['type'];
    $step->component_options = isset($element['component']['options']) ? $element['component']['options'] : NULL;
    $step->component_validation = isset($element['component']['validation']) ? $element['component']['validation'] : NULL;
    $step->component_default = isset($element['component']['default']) ? $element['component']['default'] : NULL;
    $step->component_redirect = isset($element['component']['redirect']) ? $element['component']['redirect'] : NULL;
    $step->component_value = isset($element['component']['value']) ? $element['component']['value'] : NULL;
    $step->component_callback = isset($element['component']['callback']) ? $element['component']['callback'] : NULL;

    steps_steps_ops($step);
  }
}

/**
 * Implements hook_permission()
 */
function steps_permission() {
  // Only create permissions to wizards
  // If we create permissions to steps the whole API becomes really hard to manage
  // but we can create permissions on the wizard level
  if($wizard = _wizard_implements()) {
    foreach($wizard as $key => $main) {
      return array(
        "configure wizard $key" => array(
          'title' => t("Configure wizard !title", array('!title' => $main['title'])),
          'description' => t("Configure the wizard !title", array('!title' => $main['title'])),
        ),
      );
    }
  }
}

/**
 * Implements hook_menu().
 */
function steps_menu() {
  $items = array();
  
  /**
   * Create all wizards
   * The path will be the main path but the page callback is a simple redirection to the
   * start_path
   */
  $wizards = steps_get_wizard();
  foreach($wizards as $wizard) {
    $items[$wizard->main_path] = array(
      'title' => $wizard->title,
      'page callback' => '_steps_redirect',
      'page arguments' => array($wizard->start_path),
      'access arguments' => array("configure form " . $wizard->wizard),
      'type' => MENU_NORMAL_ITEM,
    );  
  }
  
  // Implement all steps paths
  if($steps = _steps_implements()) {
    foreach($steps as $key => $step) {
      $items[$step->path] = array(
        'title' => $step->title,
        'page callback' => 'drupal_get_form',
        'page arguments' => array("steps_form", $step->step),
        'access arguments' => array("configure wizard " . $step->wizard),
        'type' => MENU_NORMAL_ITEM,
      );  
    }
  }
   
  /**
   * Remove later
   */
  $items['admin/config/steps'] = array(
    'title' => 'Steps',
    'description' => 'Debug steps',
    'page callback' => 'steps_debug',
    'access arguments' => array("administer modules"),
    'file' => 'steps.admin.inc',
  );
  
  return $items;
}

/**
 * Insert and update operations for wizards
 */
function steps_wizard_ops($wizard) {
  // Check if the current wizard object exists
  $result = db_select("steps_wizard", "w")
            ->fields("w", array("wizard"))
            ->condition("wizard", $wizard->wizard, "=")
            ->execute()
            ->fetchAssoc();  
  
  // If it does exists then update it, else, insert it
  if($result) {
    db_update("steps_wizard")
      ->fields(array(
        'title' => $wizard->title,
        'main_path' => $wizard->main_path,
        'start_path' => $wizard->start_path,
        'end_path' => $wizard->end_path,
      ))
      ->condition("wizard", $wizard->wizard, "=")
      ->execute();
  }
  else {
    db_insert("steps_wizard")
      ->fields(array(
        'wizard' => $wizard->wizard,
        'title' => $wizard->title,
        'main_path' => $wizard->main_path,
        'start_path' => $wizard->start_path,
        'end_path' => $wizard->end_path,
      ))
      ->execute();
  }
}

function steps_steps_ops($step) {
  // Check if the current wizard object exists
  $result = db_select("steps")
            ->fields("steps")
            ->condition("step", $step->step, "=")
            ->execute()
            ->fetchAssoc();  
  
  // If it does exists then update it, else, insert it
  if($result) {
    db_update("steps")
      ->fields(array(
        'wizard' => $step->wizard,
        'title' => $step->title,
        'path' => $step->path,
        'description' => $step->description,
        'component_type' => $step->component_type,
        'component_options' => $step->component_options,
        'component_validation' => $step->component_validation,
        'component_default' => $step->component_default,
        'component_redirect' => $step->component_redirect,
        'component_value' => $step->component_value,
        'component_callback' => $step->component_callback,
      ))
      ->condition("step", $step->step, "=")
      ->execute();
  }
  else {
    // error here
    db_insert("steps")
      ->fields(array(
        'step' => $step->step,
        'wizard' => $step->wizard,
        'title' => $step->title,
        'path' => $step->path,
        'description' => $step->description,
        'component_type' => $step->component_type,
        'component_options' => $step->component_options,
        'component_validation' => $step->component_validation,
        'component_default' => $step->component_default,
        'component_redirect' => $step->component_redirect,
        'component_value' => $step->component_value,
        'component_callback' => $step->component_callback,
      ))
      ->execute();
  }
}

/**
 * Gett all wizards from the database
 */
function steps_get_wizard($wizard = NULL) {
  if(isset($wizard)) {
    $result = db_query("SELECT * FROM {steps_wizard} WHERE wizard = :wizard", array(":wizard" => $wizard))->fetchAssoc();  
  }
  else {
    $result = db_query("SELECT * FROM {steps_wizard}")->fetchAll();
  }
  return $result;
}

/**
 * Delete wizard
 */
function steps_delete_wizard($wizard) {
  
  // Delete all steps
  $steps = db_query("SELECT * FROM {steps} WHERE wizard = :wizard", array(':wizard' => $wizard))->fetchAll();
  foreach($steps as $step) {
    steps_delete_step($step->step);
  }
  
  db_delete("steps_wizard")
  ->condition("wizard", $wizard, "=")
  ->execute();
}

/**
 * Gett all steps from the database
 */
function steps_get_steps($wizard = NULL) {
  if(isset($wizard)) {
    $result = db_query("SELECT * FROM {steps} WHERE wizard = :wizard", array(':wizard' => $wizard->wizard))->fetchAll();  
  }
  else {
    $result = db_query("SELECT * FROM {steps}")->fetchAll();
  }
  
  return $result;
}

/**
 * Get a step
 */
function steps_get_step($key) {
  return db_query("SELECT * FROM {steps} WHERE step = :step", array(':step' => $key))->fetchAssoc();
}

/**
 * Delete step
 */
function steps_delete_step($step) {
  db_delete("steps")
  ->condition("step", $step)
  ->execute();
}

/**
 * Get the values of all steps using the same token
 */
function steps_value_get($token) {
  $results = db_query("SELECT * FROM {steps_values} WHERE token = :token", array(':token' => $token))->fetchAll();
  $data = array();
  foreach($results as $result) {
    $data[$result->step] = array(
      'token' => $result->token,
      'wizard' => $result->wizard,
      'uid' => $result->uid,
      'step' => $result->step,
      'value' => $result->value
    );
  }
  
  return $data;
}

/**
 * Perform operations on the steps_values table
 * 
 * @param $op
 * -- insert Insert a value into the steps_value table
 * -- delete Delete a value into the steps_value table
 */
function steps_value_op($op, $object) {
  switch ($op) {
    case "insert":
       db_insert("steps_values")
        ->fields(array(
          'token' => $object['token'],
          'wizard' => $object['wizard'],
          'uid' => $object['uid'],
          'step' => $object['step'],
          'value' => $object['value'],
        ))
        ->execute();
      break;

    case "delete":
      db_delete("steps_values")
        ->condition("token", $object['token'])
        ->execute();
      break;
  } 
}

/**
 * Get all the steps values for a wizard
 */
function steps_value_get_by_wizard($wizard) {
  return db_query("SELECT * FROM {steps_values} WHERE wizard = :wizard", array(':wizard' => $wizard))->fetchAssoc();
}

/**
 * Get all steps values for a wizard in a given step
 */
function steps_value_get_by_wizard_and_step($wizard, $step) {
  return db_query("SELECT * FROM {steps_values} WHERE wizard = :wizard AND step = :step", array(':wizard' => $wizard, ':step' => $step))->fetchAssoc();
}

/**
 * Simple redirect from the main path to the start path
 */
function _steps_redirect($path) {
  drupal_goto($path);
}

/**
 * Form callback
 * 
 * @param $args the step key is passed directly from the url, from there
 * will be calling the form everytime another step is given since the redirection
 * for the next step is given in the submit callback, basically is just:
 * 
 * step_form(step1) -> step_form_submit(step1) -> step_form(step2) -> step_form_submit(step2) -> etc
 */
function steps_form($form, $args) {
  global $user;
  $form = array();
  
  // Should I check for access?
  
  $step = steps_get_step($args['build_info']['args'][0]);
  $stepkey = $step['step'];
  $wizard = steps_get_wizard($step['wizard']);
  $current_path = $step['path'];
  
  drupal_alter("steps_form_pre", $form);
  drupal_alter("steps_form_pre_" . $stepkey, $form);
  
  // Save the step to send it to the submit callback
  $form['_step'] = array(
    '#value' => $step,
  );
  
  if($wizard['start_path'] == $current_path) {
    // for protection, delete all records that correspond to this user
    db_delete("steps_values")
      ->condition("wizard", $step['wizard'])
      ->condition("uid", $user->uid)
      ->execute();
    
    // If this is the first path, create a new object
    $token = drupal_hash_base64(drupal_random_bytes(55));
    // The object will be incomplete until we add the step and the value, we just initialize it here
    $build_object = array(
      'wizard' => $wizard['wizard'],
      'uid' => $user->uid,
      'token' => $token
    );
  }
  else {
    // get the object using the wizard and the step and pass it again
    $object = steps_value_get_by_wizard($step['wizard']);
    $token = $object['token'];
    
    $build_object = array(
      'wizard' => $object['wizard'],
      'uid' => $object['uid'],
      'token' => $token
    );
    
  }
  
  $form['_build_object'] = array(
    '#type' => 'value',
    '#value' => $build_object
  );
  
  // Switch depending on the component_type of the step
  // this way will be easier to ignore elements and validate them
  // depending on our own specifications
  drupal_alter("steps_form_" . $stepkey . '_' . $step['component_type'], $form);
  switch($step['component_type']) {
    case "radios" :
    case "select" :
      $form[$stepkey] = array(
        '#type' => $step['component_type'],
        '#title' => isset($step['description']) ? $step['description'] : $step['title'],
        '#description' => $step['description'],
        '#default_value' => $step['component_default'],
        '#required' => TRUE,
      );
      
      if(isset($step['component_options'])) {
        $options_arr = steps_pipelined_process_options($step['component_options']);
        $form[$stepkey]['#options'] = $options_arr;
      }
      
      break;
      
    case "textfield":
      $form[$stepkey] = array(
        '#type' => "textfield",
        '#title' => isset($step['description']) ? $step['description'] : $step['title'],
        '#description' => $step['description'],
        '#default_value' => $step['component_default'],
        '#required' => TRUE,
      );

      break;
      
    case "textarea":
      $form[$stepkey] = array(
        '#type' => "textarea",
        '#title' => isset($step['description']) ? $step['description'] : $step['title'],
        '#description' => $step['description'],
        '#default_value' => $step['component_default'],
        '#required' => TRUE,
      );
      break;
      
    case "checkboxes":
      $form[$stepkey] = array(
        '#type' => "checkboxes",
        '#title' => isset($step['description']) ? $step['description'] : $step['title'],
        '#description' => $step['description'],
        '#required' => TRUE,
      );
      
      if(isset($step['component_options'])) {
        $options_arr = steps_pipelined_process_options($step['component_options']);
        $form[$stepkey]['#options'] = $options_arr;
      }
      break;
      
    case "markup":
      $form[$stepkey] = array(
        '#type' => "markup",
        '#title' => $step['title'],
        '#markup' => $step['component_value'],
      );
      break;

    case "form":
      // Print the form here
      // $form = array_merge($form, drupal_get_form($step["component_callback"], $step));
      // drupal_alter("steps_form_" . $step["component_callback"], $form);
      $function = $step["component_callback"];
      if(function_exists($function)) {
        $form[] = $function($form);
      }
      
      break;
  }

  // Check if the current path is the final path
  if($wizard['end_path'] == $current_path) {
    $final_path = TRUE;
  }
  else {
    $final_path = FALSE;
    $form['_is_final'] = array(
      '#value' => FALSE,
      '#type' => "value",
    );
  }
  
  // Check if the path is the final path, if it is not, then show the button
  if($final_path === FALSE) {
    $form['actions']['#type'] = 'actions';
    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => t("Next"),
    );
  }
  
  $form['#submit'][] = "steps_form_submit";
  
  drupal_alter("steps_form_post_" . $stepkey, $form);
  drupal_alter("steps_form_post", $form);
  
  return $form;
}

/**
 * Get the redirection value of the given option for a particular step
 * 
 * @return string the redirect path
 */
function steps_redirect_to($step, $option) {
  // Make them piped
  $val_arr = steps_pipelined_process_options($step['component_validation']);
  return $val_arr[$option];
}

/**
 * Submit callback
 */
function steps_form_submit($form, &$form_state) {
  // Variable has the key of this step
  $step = $form_state['complete form']['_step']['#value'];
  $stepkey = $form_state['complete form']['_step']['#value']['step'];
  $component_type = $form_state['complete form']['_step']['#value']['component_type'];
  
  $get_build_object = $form_state['values']['_build_object'];
  $build_object = array(
    'step' => $stepkey,
  );
  
  // Check if the form type is a checklist, in which case we need to
  // serialize the value
  if($component_type == "checkboxes") {
    $build_object['value'] = serialize($form_state['values'][$stepkey]);
  }
  else {
    $build_object['value'] = $form_state['values'][$stepkey];
  }
  
  $finished_object = array_merge($get_build_object, $build_object);
  steps_value_op("insert", $finished_object);
  
  
  
  // Save the build object for each time we run submit
  
  
  // variable_set($variable, $form_state[$variable]['#value']);
  // If there is a redirect with no options go to it
  
  $steps_wizard = array();
  $value = $form_state['values'][$stepkey];
  // dsm($form_state);
  
  // We need to remove the database operation and use $_POST to save the values
  // $_POST[$stepkey] = array_merge($get_build_object, $build_object);
  // $_POST["test_" . $stepkey] = array_merge($_POST["test_" . $stepkey], $finished_object);
  
  // Check if the path we're redirecting is the last one
  $wizard = steps_get_wizard($step['wizard']);
  // If the path we're redirecting is the path where the wizard ends then
  // even though the submit callback doesn't really know that the last form
  // callback is showing up, we tell the submit callback that this is the end
  // and that there will be no other submit callback run (no button anymore)
  // so perform all the last minute operations in the previous to last submit callback
  if($step['component_redirect'] == $wizard['end_path']) {
    // Also check if the form has no component_redirect but if the 
    // selected option had as the validation path to redirect to the $wizard["end_path"]
    
    // Get the token
    $token = $get_build_object['token'];
    // Build the array using the token
    $data = steps_value_get($token);
    
    // Delete it from the db
    db_delete("steps_values")
      ->condition("token", $token)
      ->execute();
      
    // Now we process the data array here using hook_steps_$wizard
    steps_invoke($step['wizard'], $data);
    
    
  }
  
  if(!empty($step['component_redirect'])) { 
    drupal_goto($step['component_redirect']);
  }
  else {
    $option = $form_state['values'][$stepkey];
    $redirect = steps_redirect_to($step, $option);
  
    drupal_goto($redirect);
  } 
}

/**
 * Invoke all functions that do something with the data array
 * Example, if our wizard is called "event", we would implement
 * something like hook_steps_event(&$data) so we can
 * manipulate the object at our will and do anything with it.
 */
function steps_invoke($wizard, &$data) {
  $return = array();
  foreach(module_implements("steps_" . $wizard) as $name) {
    $function = $name . "_steps_" . $wizard;
    $result = $function($data);
    if(isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if(isset($result)){
      $return[] = $result;
    }
  }
  
  return $return;
}

/**
 * Converts pipelined values into an array
 */
function steps_pipelined_process_options($values) {
  // process the piped options
  $lines = explode("\n", trim($values));
  $matches = array();
  $options_arr = array();
  foreach ($lines as $line) {
    $line = trim($line);
  
    if (preg_match('/^([^|]*)\|(.*)$/', $line, $matches)) {
      $key = $matches[1];
      $vals = $matches[2];
      
      $options_arr[$key] = $vals;
    }
  }
  
  return $options_arr;
}

/*
 * Implements hook_custom_theme()
 */
function steps_custom_theme() {
  $admin_theme = variable_get('admin_theme');
  $steps_theme = variable_get("steps_theme");
  
  if(isset($steps_theme)) {
    $theme = $steps_theme;
  }
  else if(isset($admin_theme) && !isset($steps_theme)) {
    $theme = $admin_theme;
  }
  
  // Get all the paths
  $paths = db_query("SELECT path FROM {steps}")->fetchAll();
  // Loop
  foreach($paths as $path) {
    // Check if the current path is registered as a step path
    if(current_path() == $path->path) {
      return $theme;
    }
  }
}
