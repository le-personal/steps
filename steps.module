<?php

define('STEP_IS_FINAL', 1);

/**
 * Collects all hook_wizard implementations
 */
function _wizard_implements() {
  $wizard = array();
  foreach(module_list() as $module) {
    if($data = module_invoke($module, 'wizard')) {
      $wizard = array_merge($data, $wizard);
    }
  }
  
  return $wizard;
}

/**
 * Collects all hook_steps implementations
 */
function _steps_implements() {
  $steps = steps_get_steps();
  /*
  $steps = array();
  foreach(module_list() as $module) {
    if($data = module_invoke($module, 'steps')) {
      $steps = array_merge($data, $steps);
    }
  }
  */
  
  return $steps;
}

/**
 * Implements hook_enable()
 */
function steps_enable() {
  /**
   * Create all menu links implementing hook_wizard
   */
  $wizards = _wizard_implements();
  foreach($wizards as $key => $element) {
    $wizard = new stdClass();
    $wizard->wizard = $key;
    $wizard->title = check_plain($element['title']);
    $wizard->main_path = check_plain($element['main_path']);
    $wizard->start_path = check_plain($element['start_path']);
    $wizard->end_path = check_plain($element['end_path']);
    
    steps_wizard_ops($wizard);
  }
  
  /**
   * Create all menus implementing hook_steps
   * There is a problem with how the db_insert is handling array of arrays
   * like in options and validations
   */
  $steps = _steps_implements();
  foreach($steps as $key => $element) {
    $step = new stdClass();
    $step->step = $key;
    $step->wizard = check_plain($element['wizard']);
    $step->title = check_plain($element['title']);
    $step->path = check_plain($element['path']);
    $step->description = isset($element['description']) ? check_plain($element['description']) : NULL;
    $step->component_type = $element['component']['type'];
    $step->component_options = isset($element['component']['options']) ? $element['component']['options'] : NULL;
    $step->component_validation = isset($element['component']['validation']) ? $element['component']['validation'] : NULL;
    $step->component_default = isset($element['component']['default']) ? $element['component']['default'] : NULL;
    $step->component_redirect = isset($element['component']['redirect']) ? $element['component']['redirect'] : NULL;
    $step->component_value = isset($element['component']['value']) ? $element['component']['value'] : NULL;
    $step->component_callback = isset($element['component']['callback']) ? $element['component']['callback'] : NULL;

    steps_steps_ops($step);
  }
}

/**
 * Implements hook_permission()
 */
function steps_permission() {
  // Only create permissions to wizards
  // If we create permissions to steps the whole API becomes really hard to manage
  // but we can create permissions on the wizard level
  if($wizard = _wizard_implements()) {
    foreach($wizard as $key => $main) {
      return array(
        "configure wizard $key" => array(
          'title' => t("Configure wizard !title", array('!title' => $main['title'])),
          'description' => t("Configure the wizard !title", array('!title' => $main['title'])),
        ),
      );
    }
  }
}

/**
 * Implements hook_menu().
 */
function steps_menu() {
  $items = array();
  
  /**
   * Create all wizards
   * The path will be the main path but the page callback is a simple redirection to the
   * start_path
   */
  $wizards = steps_get_wizard();
  foreach($wizards as $wizard) {
    $items[$wizard->main_path] = array(
      'title' => $wizard->title,
      'page callback' => '_steps_redirect',
      'page arguments' => array($wizard->start_path),
      'access arguments' => array("configure form " . $wizard->wizard),
      'type' => MENU_NORMAL_ITEM,
    );  
  }
  
  // Implement all steps paths
  if($steps = _steps_implements()) {
    foreach($steps as $key => $step) {
      $items[$step->path] = array(
        'title' => $step->title,
        'page callback' => 'drupal_get_form',
        'page arguments' => array("steps_form", $step->step),
        'access arguments' => array("configure wizard " . $step->wizard),
        'type' => MENU_NORMAL_ITEM,
      );  
    }
  }
   
  /**
   * Remove later
   */
  $items['admin/config/steps'] = array(
    'title' => 'Steps',
    'description' => 'Debug steps',
    'page callback' => 'steps_debug',
    'access arguments' => array("administer modules"),
    'file' => 'steps.admin.inc',
  );
  
  return $items;
}

/**
 * Insert and update operations for wizards
 */
function steps_wizard_ops($wizard) {
  // Check if the current wizard object exists
  $result = db_select("steps_wizard", "w")
            ->fields("w", array("wizard"))
            ->condition("wizard", $wizard->wizard, "=")
            ->execute()
            ->fetchAssoc();  
  
  // If it does exists then update it, else, insert it
  if($result) {
    db_update("steps_wizard")
      ->fields(array(
        'title' => $wizard->title,
        'main_path' => $wizard->main_path,
        'start_path' => $wizard->start_path,
        'end_path' => $wizard->end_path,
      ))
      ->condition("wizard", $wizard->wizard, "=")
      ->execute();
  }
  else {
    db_insert("steps_wizard")
      ->fields(array(
        'wizard' => $wizard->wizard,
        'title' => $wizard->title,
        'main_path' => $wizard->main_path,
        'start_path' => $wizard->start_path,
        'end_path' => $wizard->end_path,
      ))
      ->execute();
  }
}

function steps_steps_ops($step) {
  // Check if the current wizard object exists
  $result = db_select("steps")
            ->fields("steps")
            ->condition("step", $step->step, "=")
            ->execute()
            ->fetchAssoc();  
  
  // If it does exists then update it, else, insert it
  if($result) {
    db_update("steps")
      ->fields(array(
        'wizard' => $step->wizard,
        'title' => $step->title,
        'path' => $step->path,
        'description' => $step->description,
        'component_type' => $step->component_type,
        'component_options' => $step->component_options,
        'component_validation' => $step->component_validation,
        'component_default' => $step->component_default,
        'component_redirect' => $step->component_redirect,
        'component_value' => $step->component_value,
        'component_callback' => $step->component_callback,
      ))
      ->condition("step", $step->step, "=")
      ->execute();
  }
  else {
    // error here
    db_insert("steps")
      ->fields(array(
        'step' => $step->step,
        'wizard' => $step->wizard,
        'title' => $step->title,
        'path' => $step->path,
        'description' => $step->description,
        'component_type' => $step->component_type,
        'component_options' => $step->component_options,
        'component_validation' => $step->component_validation,
        'component_default' => $step->component_default,
        'component_redirect' => $step->component_redirect,
        'component_value' => $step->component_value,
        'component_callback' => $step->component_callback,
      ))
      ->execute();
  }
}

/**
 * Gett all wizards from the database
 */
function steps_get_wizard($wizard = NULL) {
  if(isset($wizard)) {
    $result = db_query("SELECT * FROM {steps_wizard} WHERE wizard = :wizard", array(":wizard" => $wizard))->fetchAssoc();  
  }
  else {
    $result = db_query("SELECT * FROM {steps_wizard}")->fetchAll();
  }
  return $result;
}

/**
 * Delete wizard
 */
function steps_delete_wizard($wizard) {
  
  // Delete all steps
  $steps = db_query("SELECT * FROM {steps} WHERE wizard = :wizard", array(':wizard' => $wizard))->fetchAll();
  foreach($steps as $step) {
    steps_delete_step($step->step);
  }
  
  db_delete("steps_wizard")
  ->condition("wizard", $wizard, "=")
  ->execute();
}

/**
 * Gett all steps from the database
 */
function steps_get_steps($wizard = NULL) {
  if(isset($wizard)) {
    $result = db_query("SELECT * FROM {steps} WHERE wizard = :wizard", array(':wizard' => $wizard->wizard))->fetchAll();  
  }
  else {
    $result = db_query("SELECT * FROM {steps}")->fetchAll();
  }
  
  return $result;
}

/**
 * Get a step
 */
function steps_get_step($key) {
  return db_query("SELECT * FROM {steps} WHERE step = :step", array(':step' => $key))->fetchAssoc();
}

/**
 * Delete step
 */
function steps_delete_step($step) {
  db_delete("steps")
  ->condition("step", $step)
  ->execute();
}

/**
 * Simple redirect from the main path to the start path
 */
function _steps_redirect($path) {
  drupal_goto($path);
}

/**
 * Form callback
 * 
 * @param $args the step key is passed directly from the url, from there
 * will be calling the form everytime another step is given since the redirection
 * for the next step is given in the submit callback, basically is just:
 * 
 * step_form(step1) -> step_form_submit(step1) -> step_form(step2) -> step_form_submit(step2) -> etc
 */
function steps_form($form, $args) {
  $form = array();
  
  // Should I check for access?
  
  $step = steps_get_step($args['build_info']['args'][0]);
  $stepkey = $step['step'];
  $wizard = steps_get_wizard($step['wizard']);
  $current_path = $step['path'];
  
  // Check if the current path is the final path
  if($wizard['end_path'] == $current_path) {
    $final_path = TRUE;
  }
  else {
    $final_path = FALSE;
  }
  
  drupal_alter("steps_form_pre", $form);
  drupal_alter("steps_form_pre_" . $stepkey, $form);
  
  // Save the step to send it to the submit callback
  $form['_step'] = array(
    '#value' => $step,
  );
  
  // Switch depending on the component_type of the step
  // this way will be easier to ignore elements and validate them
  // depending on our own specifications
  drupal_alter("steps_form_" . $step['component_type'], $form);
  switch($step['component_type']) {
    case "radios" :
    case "select" :
      $form[$stepkey] = array(
        '#type' => $step['component_type'],
        '#title' => $step['title'],
        '#description' => $step['description'],
        '#default_value' => $step['component_default'],
        '#required' => TRUE,
      );
      
      if(isset($step['component_options'])) {
        $options_arr = steps_pipelined_process_options($step['component_options']);
        $form[$stepkey]['#options'] = $options_arr;
      }
      
      break;
      
    case "textfield":
      $form[$stepkey] = array(
        '#type' => "textfield",
        '#title' => $step['title'],
        '#description' => $step['description'],
        '#default_value' => $step['component_default'],
        '#required' => TRUE,
      );

      break;
      
    case "textarea":
      $form[$stepkey] = array(
        '#type' => "textarea",
        '#title' => $step['title'],
        '#description' => $step['description'],
        '#default_value' => $step['component_default'],
        '#required' => TRUE,
      );
      break;
      
    case "checkboxes":
      $form[$stepkey] = array(
        '#type' => "checkboxes",
        '#title' => $step['title'],
        '#description' => $step['description'],
        '#required' => TRUE,
      );
      
      if(isset($step['component_options'])) {
        $options_arr = steps_pipelined_process_options($step['component_options']);
        $form[$stepkey]['#options'] = $options_arr;
      }
      break;
      
    case "markup":
      $form[$stepkey] = array(
        '#type' => "markup",
        '#title' => $step['title'],
        '#markup' => $step['component_value'],
      );
      break;

    case "form":
      // Print the form here
      // $form = array_merge($form, drupal_get_form($step["component_callback"], $step));
      // drupal_alter("steps_form_" . $step["component_callback"], $form);
      $function = $step["component_callback"];
      if(function_exists($function)) {
        $form[] = $function($form);
      }
      
      break;
  }
  
  // Check if the path is the final path, if it is not, then show the button
  if($final_path === FALSE) {
    $form['actions']['#type'] = 'actions';
    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => t("Next"),
    );
  }
  
  $form['#submit'][] = "steps_form_submit";
  
  drupal_alter("steps_form_post_" . $stepkey, $form);
  drupal_alter("steps_form_post", $form);
  
  return $form;
}

/**
 * Get the redirection value of the given option for a particular step
 * 
 * @return string the redirect path
 */
function steps_redirect_to($step, $option) {
  // Make them piped
  $val_arr = steps_pipelined_process_options($step['component_validation']);
  return $val_arr[$option];
}

/**
 * Submit callback
 */
function steps_form_submit($form, &$form_state) {
  // Variable has the key of this step
  $step = $form_state['complete form']['_step']['#value'];
  $stepkey = $form_state['complete form']['_step']['#value']['step'];
  
  // variable_set($variable, $form_state[$variable]['#value']);
  // If there is a redirect with no options go to it
  
  if(!empty($step['component_redirect'])) { 
    drupal_goto($step['component_redirect']);
  }
  else {
    $option = $form_state['values'][$stepkey];
    $redirect = steps_redirect_to($step, $option);
  
    drupal_goto($redirect);  
  }
  
}

function steps_pipelined_process_options($values) {
  // process the piped options
  $lines = explode("\n", trim($values));
  $matches = array();
  $options_arr = array();
  foreach ($lines as $line) {
    $line = trim($line);
  
    if (preg_match('/^([^|]*)\|(.*)$/', $line, $matches)) {
      $key = $matches[1];
      $vals = $matches[2];
      
      $options_arr[$key] = $vals;
    }
  }
  
  return $options_arr;
}
